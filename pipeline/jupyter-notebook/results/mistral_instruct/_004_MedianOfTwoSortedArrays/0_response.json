{"is_extracted": true, "number_of_code_blocks": 1, "extra_information_num_words": 35, "response": " Here is the complete file with the solution:\n\n```\npackage _004_MedianOfTwoSortedArrays;\n\nimport static java.util.stream.IntStream.rangeClosed;\n\n/** see test {@link _004_MedianOfTwoSortedArrays.PracticeTest } */\npublic class Practice {\n\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int totalSize = nums1.length + nums2.length;\n        if (totalSize % 2 == 0) { // even number of elements\n            return findMedianOfTwoSortedArraysEvenLength(nums1, nums2);\n        } else { // odd number of elements\n            return findMedianOfTwoSortedArraysOddLength(nums1, nums2);\n        }\n    }\n\n    private double findMedianOfTwoSortedArraysEvenLength(int[] nums1, int[] nums2) {\n        int m = nums1.length;\n        int n = nums2.length;\n        int start = (m > n) ? 0 : 1; // determine which array to use as low index in mergeSort\n        int mid1 = (m + n + 1) / 2; // middle index of nums1\n        int mid2 = mid1 - start; // middle index of nums2\n        \n        return findKthElement(nums1, 0, m, nums2, 0, n, mid1) + findKthElement(nums1, 0, m, nums2, 0, n, mid2);\n    }\n\n    private double findMedianOfTwoSortedArraysOddLength(int[] nums1, int[] nums2) {\n        int m = nums1.length;\n        int n = nums2.length;\n        int start = (m > n) ? 0 : 1; // determine which array to use as low index in mergeSort\n        \n        return findKthElement(nums1, 0, m, nums2, 0, n, (m + n) / 2);\n    }\n\n    private int findKthElement(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) {\n        if (end1 + end2 < k) { // mergeSort\n            return mergeSort(nums1, start1, end1, nums2, start2, end2);\n        } else if (start1 <= end1 && start2 <= end2) { // binary search in merged array\n            int mid = (start1 + end1 + start2 + end2) / 2;\n            int leftSize = mid - start1;\n            \n            if (nums1[mid] == nums2[mid]) { // median is at this position\n                return nums1[mid];\n            } else if (leftSize < k) { // search in the right part of the merged array\n                return findKthElement(rangeToIntArray(nums1, mid + 1, end1), mid + 1, end1, nums2, start2, end2, k - (mid - start1 + 1));\n            } else { // search in the left part of the merged array\n                return findKthElement(nums1, start1, mid, nums2, start2, end2, k);\n            }\n        } else { // error: arrays are not sorted or passed invalid indices\n            throw new IllegalArgumentException(\"Invalid input\");\n        }\n    }\n\n    private int mergeSort(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2) {\n        if (end1 - start1 <= 0 && end2 - start2 <= 0) { // base case: both arrays are empty or contain one element each\n            return rangeClosed(start1, end1).mapToInt(i -> nums1[i]).sum() > rangeClosed(start2, end2).mapToInt(j -> nums2[j]).sum() ? nums1[start1] : nums2[start2];\n        }\n        \n        int mid1 = start1 + (end1 - start1) / 2; // middle index of nums1\n        int mid2 = mid1 + (end2 - mid1); // middle index of nums2\n        \n        int left1 = mergeSort(nums1, start1, mid1, nums2, start2, mid2);\n        int right1 = mergeSort(nums1, mid1 + 1, end1, nums2, mid2 + 1, end2);\n        \n        return left1 < right1 ? left1 : right1;\n    }\n\n    private int[] rangeToIntArray(int[] nums, int start, int end) {\n        int[] result = new int[end - start + 1];\n        System.arraycopy(nums, start, result, 0, result.length);\n        return result;\n    }\n}\n```\n\nThis solution uses merge sort to merge the two sorted arrays and find the median. The overall time complexity is O(log m + log n) = O(log (m+n))."}