{"is_extracted": true, "number_of_code_blocks": 1, "extra_information_num_words": 33, "response": " Here is the fixed Java code:\n\n```\npackage _007_ReverseInteger;\n\n/** see test {@link _007_ReverseInteger.PracticeTest } */\npublic class Practice {\n    static long reverseLong(long num) {\n        long reversedNum = 0;\n        while (num != 0) {\n            long digit = num % 10;\n            num /= 10;\n            reversedNum = reversedNum * 10 + digit;\n        }\n        return reversedNum;\n    }\n\n    public int reverse(int a) {\n        long reversedNum = reverseLong((long)a);\n        if (reversedNum > Integer.MAX_VALUE || reversedNum < Integer.MIN_VALUE) {\n            return 0;\n        } else {\n            return (int)reversedNum;\n        }\n    }\n}\n```\n\nThe main change is to check if the result is negative as well in addition to checking for positive overflow. This should fix the test case with `Integer.MIN_VALUE`."}