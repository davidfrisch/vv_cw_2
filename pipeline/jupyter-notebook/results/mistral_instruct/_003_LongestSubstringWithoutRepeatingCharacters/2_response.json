{"is_extracted": true, "number_of_code_blocks": 1, "extra_information_num_words": 10, "response": " Here is the corrected Java code for the given problem:\n\n```\n/**\n * Description:\n * \n * Given a string, find the length of the longest substring without repeating characters. For example, the longest substring\n * without repeating letters for \"abcabcbb\" is \"abc\", which the length is 3. For \"bbbbb\" the longest substring is \"b\",\n * with the length of 1.\n * \n * @tag : Hash Table; Two Pointers; String\n * {@link https://leetcode.com/problems/longest-substring-without-repeating-characters/ }\n */\npackage _003_LongestSubstringWithoutRepeatingCharacters;\n\nimport java.util.HashMap;\n\n/** see test {@link _003_LongestSubstringWithoutRepeatingCharacters.PracticeTest} */\npublic class Practice {\n\n    public int lengthOfLongestSubstring(String s) {\n        if (s == null || s.length() <= 1) {\n            return s != null ? s.length() : 0;\n        }\n\n        HashMap<Character, Integer> charMap = new HashMap<>(); // stores the index of last occurrence of a character in the string\n        int maxLen = 0, start = 0; // the length of longest substring and its starting index\n\n        for (int i = 0; i < s.length(); i++) {\n            char currentChar = s.charAt(i);\n            if (charMap.containsKey(currentChar) && charMap.get(currentChar) >= start) {\n                // this character has already appeared in the substring between start and i-1, so we move start forward\n                start = charMap.get(currentChar) + 1;\n            } else {\n                maxLen = Math.max(maxLen, i - start + 1); // update the longest length if needed\n                charMap.put(currentChar, i); // add this character to the map and remember its index\n            }\n        }\n\n        return maxLen;\n    }\n}\n```"}