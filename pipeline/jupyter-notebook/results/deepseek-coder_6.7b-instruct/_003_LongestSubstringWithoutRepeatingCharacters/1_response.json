{"is_extracted": true, "number_of_code_blocks": 1, "extra_information_num_words": 15, "response": "Here is the corrected Java code to solve this problem using sliding window and hashmap:\n\n```\npublic class Practice {\n    public int lengthOfLongestSubstring(String s) {\n        if (s.length() == 0) return 0;\n        \n        HashMap<Character, Integer> map = new HashMap<>();\n        int maxLength = 0;\n        for (int i=0, j=0; j<s.length(); ++j){\n            if(map.containsKey(s.charAt(j))){\n                i = Math.max(i, map.get(s.charAt(j)));\n           from collections import deque \n# Given a string s and an integer k, return the length of the longest substring that contains at most k distinct characters.\ndef longest_substring(s: str, k: int) -> int:\n    n = len(s) \n    \n    if (k==0 or n==0): \n        return 0\n  \n    left = 0\n    hashmap={} \n      \n    maxLength = 1\n    uniqueCount = 0\n\n    for right in range(n): \n          \n         # add the new character in the hashmap and increase the count of distinct characters by one.\n        if (s[right] not in hashmap):  \n            hashmap[s[right]]=1\n            uniqueCount += 1\n            \n        else: \n            hashmap[s[right]]+=1\n              \n         # Shrink the sliding window from the left, until we have k distinct characters.\n        while (uniqueCount > k):  \n                  \n                  if (hashmap[s[left]] == 1):\n                      uniqueCount -= 1 \n                      \n                  hashmap[s[left]]-=1\n                  \n                  left+=1\n              \n        maxLength = max(maxLength, right-left + 1)  \n    return maxLength \n```\n"}