{"is_extracted": true, "number_of_code_blocks": 1, "extra_information_num_words": 1, "response": "```\n/**\n ***************************************************************************\n * Description:\n * \n * Given a string, find the length of the longest substring without repeating \n * characters. For example, the longest substring without repeating letters \n * for \"abcabcbb\" is \"abc\", which the length is 3. For \"bbbbb\" the longest \n * substring is \"b\", with the length of 1.\n * \n ***************************************************************************\n * @tag : Hash Table; Two Pointers; String\n * {@link https://leetcode.com/problems/longest-substring-without-repeating-characters/ }\n */\npackage _003_LongestSubstringWithoutRepeatingCharacters;\n\n/** see test {@link _003_LongestSubstringWithoutRepeatingCharacters.PracticeTest } */\npublic class Practice {\n\n    public int lengthOfLongestSubstring(String a) {\n        // Implement the logic to find the length of the longest substring without repeating characters\n        // e.g. \"abcabcbb\" should return 3 as the result\n        // Your implementation here...\n        // Your correct implementation here...\n        int maxLength = 0;\n        int start = 0;\n        Map<Character, Integer> charIndexMap = new HashMap<>();\n\n        for (int end = 0; end < a.length(); end++) {\n            char currentChar = a.charAt(end);\n            if (charIndexMap.containsKey(currentChar)) {\n                start = Math.max(start, charIndexMap.get(currentChar) + 1);\n            }\n            charIndexMap.put(currentChar, end);\n            maxLength = Math.max(maxLength, end - start + 1);\n        }\n\n        return maxLength;\n    }\n}\n```"}